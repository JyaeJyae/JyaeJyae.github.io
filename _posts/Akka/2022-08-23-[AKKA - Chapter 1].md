---
title: AKKA CH1. 아카 소개
date: 2022-08-23 15:46:32 +0900
categories: [AKKA]
tags: [Akka]
image:
  path: /assets/img/thumbnail/EffectiveCSharp/ch2.jpg
  width: 1000   # in pixels
  height: 400   # in pixels
---


## ✅ 1.1 아카란 무엇인가?

- 아카는 **아카 프로그래밍 모델**을 제공한다.
- 아카의 주목적은 클라우드에 배포하거나 다중 코어 장치에서 실행할 애플리케이션을 더 쉽게 수축할 수 있게 해주고, 다중 코어 또는 분산 시스템의 가용 계산 능력을 최대한 효율적으로 활용하는 것이다.
- 아카는 액터 프로그래밍 모델, 실행 환경 그리고 확장 가능한 애플리케이션을 구축할 때 필요한 여러 지원 도구를 제공하는 툴킷이다.

## ✅ 1.2 액터 : 간단한 정리
- 아카는 액터를 중심으로 한다. 아카가 제공하는 컴포넌트 대부분은 액터를 설정하거나, 액터를 네트워크에 연결하거나, 액터를 스케줄링하거나, 액터의 클러스터를 만드는 등의 사용 방법을 어떤 식으로든 지원한다.

### 메세지 브로커와 비슷
- 액터는 프로그래밍 가능한 메시지 큐를 아주 작은 크기로 줄인 것과 같다.
- 각 액터는 메서지를 받기 전까지는 아무런 일도 수행하지 않는다.
- **불변(Immutable)** : 메세지는 일단 생성된 다음에는 변경될 수 없는 간단한 데이터 구조이다.
- 액터는 한 번에 하나의 메시지를 받을 수 있으며, 메시지를 받을 때마다 어떤 동작을 수행한다. 대기열과 다르게 액터가 다른 액터에게 메시지를 보낼 수도 있다.

### 비동기
- 액터가 수행하는 모든 것은 **비동기적**으로 실행된다.
- 응답을 기다리지 않고 액터에게 메시지를 보낼 수 있다.
- 액터와 스레드의 관계가 고정되어 있지는 않다.

종속성 삽입(Dependency Injection)을 활용하여 자주 사용되는 객체를 생성했다가 이를 재활용하는 방법이다.
    
## ✅ 1.3 확장성에 대한 두가지 방법: 예제 준비하기
### 전통적인 접근 방법 vs. 아카의 접근 방법
| 목표                  | 전통적인 접근 방법                                                                                       | 아카의 접근 방법                                                                          |
|-----------------------|----------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| 규모 확장             | - 스레드, 데이터 베이스로 변경할 수 있는 상태를   공유(생성, 삽입, 갱신, 삭제)      - 웹 서비스 PRC 호출 | - 메시지를 주고 받는 액터, 공유하는 상태   없음.      - 변경 할 수 없는 이벤트 기록       |
| 상호 작용한 정보 제공 | 현재 정보를 폴링해서 가져옴                                                                              | 이벤트 기반: 이벤트 발생 시 푸시                                                          |
| 네트워크 확장 하기    | 동기 RPC, 블로킹 I/O                                                                                     | 비동기 메시지, 논블로킹 I/O                                                               |
| 실패 처리             | - 모든 예외를 처리함      - 모든 것이 잘 잘동할 때만 계속 진행                                           | - 문제 발생시 (그 부분만) 중단함      - 실패한 부분을 격리 시키고 나머지 부분을 계속 진행 |

## ✅ 1.4 전통적인 규모 확장
- 처음에는 서버 한 대로 시작한다. 현재로서는 객체 모두 메모리에 유지할 것이다.
- ![1-3](/assets/img/post/AKKA/ch1/1-3.png)
- Team은 User의 그룹이다. 여러 User는 여러 Conversation에 참여할 수 있다. Conversation들은 여러 메세지를 모은 것이다.
- 아직 애플리케이션은 메모리 안에서만 실행된다. 따라서 프로그램을 재시작하면 모든 Conversation들이 사라진다. 게다가 아직은 한 서버에서만 실행된다.

### 1.4.1 전통적인 규모 확장과 내구성: 모든 것을 데이터베이스에 저장
- 이 상황에 데이터 베이스를 추가하기로 했다. 가용성을 위해 웹 애플리케이션을 프런트엔드 서버 두대에서 실행할 것이다. 앞단에는 Load Balancer를 추가한다.
- ![1-4](/assets/img/post/AKKA/ch1/1-4.png)
- 더 이상 인메모리 객체만을 다루지는 않으므로 코드가 더 복잡해진다.
- 어떻게 해야 두 서버에서 일관성 있게 객체를 유지할 수 있을까? **상태가 없는 서버**로 만들어야한다. 모든 복잡한 기능의 객체를 데이터베이스 코드로 바꿔서 없앤다.
- 이제 더이상 객체의 상태가 웹 서버 메모리에만 존재하지 않는다. 이는 객체의 메서드가 직접 상태를 다룰 수 없다는 뜻이다. 근본적으로 모든 중요한 로직은 데이터 베이스 멸령으로 옮겨졌다.
- ![1-5](/assets/img/post/AKKA/ch1/1-5.png)

#### 문제점
**1. 객체 상태 보장 불가**
- 예를 들어 Conversation에 Message를 추가하는 메서드를 호출하는 경우를 보자
- 전에는 메모리 리스트에 단순 연산이었으므로 addMessage가 실패할 일이 없었다.
- 하지만, 이제는 addMessage 호출에 대해 데이터 베이스가 오류를 반환할 수도 있다.
  - 레코드 삽입에 실패할 수도 있고, 호출 시점에 데이터베이스를 사용할 수 없을 때도 있다.
  - 예를들어 데이터베이스 서버에 문제가 생겼다거나 네트워크 문제가 있을 때 그렇다.
**2. 동시 접근**
- 인메모리 버전에서는 여러 사용자가 데이터에 동시 접근해서 데이터를 오염시키는 것을 방지하는 락이 여기저기 흩어져 있었다.
- 레코드 중복이나 데이터 불일치도 피해야한다. 객체에 대한 간단한 호출도 모두 실질적으로는 데이터베이스 명령으로 변환되며, 그런 명령 중 일부는 서로 조화롭게 실행되어야 한다.
  - 예를 들어 Conversation을 시작했다면 적어도 Conversation과 Message 테이블에 동시에 메시지를 집어넣을 수 있어야한다.
**3. 테스트**
- 인메모리 버전에서는 테스트하기 쉬웠고 단위 테스트를 실행하는 데 걸리는 시간도 짧았다.
- 이제는 테스트를 위해 데이터 베이스 X를 로컬 서버에서 실행하고, 테스트 격리에 필요한 데이터베이스 테스트 유틸리티를 몇가지 추가해야한다.
- 단위 테스트 속도는 이제 더 느려졌다.


## ⭐정리⭐