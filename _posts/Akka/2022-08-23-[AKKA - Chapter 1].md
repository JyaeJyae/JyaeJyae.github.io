---
title: AKKA CH1. 아카 소개
date: 2022-08-23 15:46:32 +0900
categories: [AKKA]
tags: [Akka]
image:
  path: /assets/img/thumbnail/EffectiveCSharp/ch2.jpg
  width: 1000   # in pixels
  height: 400   # in pixels
---


## ✅ 1.1 아카란 무엇인가?

- 아카는 **아카 프로그래밍 모델**을 제공한다.
- 아카의 주목적은 클라우드에 배포하거나 다중 코어 장치에서 실행할 애플리케이션을 더 쉽게 수축할 수 있게 해주고, 다중 코어 또는 분산 시스템의 가용 계산 능력을 최대한 효율적으로 활용하는 것이다.
- 아카는 액터 프로그래밍 모델, 실행 환경 그리고 확장 가능한 애플리케이션을 구축할 때 필요한 여러 지원 도구를 제공하는 툴킷이다.

## ✅ 1.2 액터 : 간단한 정리
- 아카는 액터를 중심으로 한다. 아카가 제공하는 컴포넌트 대부분은 액터를 설정하거나, 액터를 네트워크에 연결하거나, 액터를 스케줄링하거나, 액터의 클러스터를 만드는 등의 사용 방법을 어떤 식으로든 지원한다.

### 메세지 브로커와 비슷
- 액터는 프로그래밍 가능한 메시지 큐를 아주 작은 크기로 줄인 것과 같다.
- 각 액터는 메서지를 받기 전까지는 아무런 일도 수행하지 않는다.
- **불변(Immutable)** : 메세지는 일단 생성된 다음에는 변경될 수 없는 간단한 데이터 구조이다.
- 액터는 한 번에 하나의 메시지를 받을 수 있으며, 메시지를 받을 때마다 어떤 동작을 수행한다. 대기열과 다르게 액터가 다른 액터에게 메시지를 보낼 수도 있다.

### 비동기
- 액터가 수행하는 모든 것은 **비동기적**으로 실행된다.
- 응답을 기다리지 않고 액터에게 메시지를 보낼 수 있다.
- 액터와 스레드의 관계가 고정되어 있지는 않다.

종속성 삽입(Dependency Injection)을 활용하여 자주 사용되는 객체를 생성했다가 이를 재활용하는 방법이다.
    
## ✅ 1.3 확장성에 대한 두가지 방법: 예제 준비하기
### 전통적인 접근 방법 vs. 아카의 접근 방법
| 목표                  | 전통적인 접근 방법                                                                                       | 아카의 접근 방법                                                                          |
|-----------------------|----------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| 규모 확장             | - 스레드, 데이터 베이스로 변경할 수 있는 상태를   공유(생성, 삽입, 갱신, 삭제)      - 웹 서비스 PRC 호출 | - 메시지를 주고 받는 액터, 공유하는 상태   없음.      - 변경 할 수 없는 이벤트 기록       |
| 상호 작용한 정보 제공 | 현재 정보를 폴링해서 가져옴                                                                              | 이벤트 기반: 이벤트 발생 시 푸시                                                          |
| 네트워크 확장 하기    | 동기 RPC, 블로킹 I/O                                                                                     | 비동기 메시지, 논블로킹 I/O                                                               |
| 실패 처리             | - 모든 예외를 처리함      - 모든 것이 잘 잘동할 때만 계속 진행                                           | - 문제 발생시 (그 부분만) 중단함      - 실패한 부분을 격리 시키고 나머지 부분을 계속 진행 |

## ✅ 1.4 전통적인 규모 확장
- 처음에는 서버 한 대로 시작한다. 현재로서는 객체 모두 메모리에 유지할 것이다.
- ![1-3](/assets/img/post/AKKA/ch1/1-3.png)
- Team은 User의 그룹이다. 여러 User는 여러 Conversation에 참여할 수 있다. Conversation들은 여러 메세지를 모은 것이다.
- 아직 애플리케이션은 메모리 안에서만 실행된다. 따라서 프로그램을 재시작하면 모든 Conversation들이 사라진다. 게다가 아직은 한 서버에서만 실행된다.

### 1.4.1 전통적인 규모 확장과 내구성: 모든 것을 데이터베이스에 저장
- 이 상황에 데이터 베이스를 추가하기로 했다. 가용성을 위해 웹 애플리케이션을 프런트엔드 서버 두대에서 실행할 것이다. 앞단에는 Load Balancer를 추가한다.
- ![1-4](/assets/img/post/AKKA/ch1/1-4.png)
- 더 이상 인메모리 객체만을 다루지는 않으므로 코드가 더 복잡해진다.
- 어떻게 해야 두 서버에서 일관성 있게 객체를 유지할 수 있을까? **상태가 없는 서버**로 만들어야한다. 모든 복잡한 기능의 객체를 데이터베이스 코드로 바꿔서 없앤다.
- 이제 더이상 객체의 상태가 웹 서버 메모리에만 존재하지 않는다. 이는 객체의 메서드가 직접 상태를 다룰 수 없다는 뜻이다. 근본적으로 모든 중요한 로직은 데이터 베이스 멸령으로 옮겨졌다.
- ![1-5](/assets/img/post/AKKA/ch1/1-5.png)

#### 문제점
**1. 객체 상태 보장 불가**
- 예를 들어 Conversation에 Message를 추가하는 메서드를 호출하는 경우를 보자
- 전에는 메모리 리스트에 단순 연산이었으므로 addMessage가 실패할 일이 없었다.
- 하지만, 이제는 addMessage 호출에 대해 데이터 베이스가 오류를 반환할 수도 있다.
  - 레코드 삽입에 실패할 수도 있고, 호출 시점에 데이터베이스를 사용할 수 없을 때도 있다.
  - 예를들어 데이터베이스 서버에 문제가 생겼다거나 네트워크 문제가 있을 때 그렇다.

**2. 동시 접근**
- 인메모리 버전에서는 여러 사용자가 데이터에 동시 접근해서 데이터를 오염시키는 것을 방지하는 락이 여기저기 흩어져 있었다.
- 레코드 중복이나 데이터 불일치도 피해야한다. 객체에 대한 간단한 호출도 모두 실질적으로는 데이터베이스 명령으로 변환되며, 그런 명령 중 일부는 서로 조화롭게 실행되어야 한다.
  - 예를 들어 Conversation을 시작했다면 적어도 Conversation과 Message 테이블에 동시에 메시지를 집어넣을 수 있어야한다.

**3. 테스트**
- 인메모리 버전에서는 테스트하기 쉬웠고 단위 테스트를 실행하는 데 걸리는 시간도 짧았다.
- 이제는 테스트를 위해 데이터 베이스 X를 로컬 서버에서 실행하고, 테스트 격리에 필요한 데이터베이스 테스트 유틸리티를 몇가지 추가해야한다.
- 단위 테스트 속도는 이제 더 느려졌다.

#### DAO와의 상호 작용
- ![1-6](/assets/img/post/AKKA/ch1/1-6.png)
- 컨트롤러가 원하는 대로 데이터베이스 연산을 조합할 수있어 쉽게 예측하기 어려운 데이터 베이스와의 상호 작용이 생겨버린다.
- **Thread + RPC**
  - 데이터 베이스 호출은 근본적으로 RPC다. 그리고 표준 데이터 베이스 드라이버는 대부분 블로킹 I/O를 사용한다.
  - 따라서 앞에서 말했던 스레드와 RPC를 함께 사용하는 상황과 같다.
  - 스레드 동기화하는데 사용하는 메모리 락과 테이블 및 레코드 변경을 보호하는데 상요되는 데이터 베이스 락은 실제로는 같지 않다.
  - 따라서 **스레드와 RPC를 함께 사용할 때는 반드시 주의를 기울여야 한다.**

### 1.4.2 전통적인 규모 확장고 상호 작용 : 폴링
- 우리는 사용자들이 진짜 대화하는 것 같은 느낌을 받을 수 있기를 원한다. 그러려면 변경된 내용을 좀 더 **빠르게** 사용자에게 반영해 줘야한다. 따라서 웹 애플리케이션은 다른 정보도 더 자주 폴링해야한다.
- **메세지 큐**
  - 사용자가 작성한 메시지는 모두 **비동기적으로 큐**에 들어갔다. 그리고 별도의 프로세스가 그 큐에서 메시지를 받아서 사용자를 검색하고 통지 테이블에 레코드를 추가한다.
- 데이터 베이스가 정말로 많은 부하를 받기 시작한다.
- **데이터 베이스의 동기화 기능을 통해 최신상태**를 유지한다.
  - ![1-7](/assets/img/post/AKKA/ch1/1-7.png)
  - 메시지 큐를 추가함으로 인해 복잡도가 또다시 증가했다.
  - 이제는 코드를 배포하기 전에 반드시 메시지 큐를 설치하고 설정해야만 한다.

### 1.4.3 전통적인 규모 확장고 상호 작용 : 웹 서비스
- 연락처 검색 기능을 추가하고자 한다. 구글 주소록 API나 마이크로소프트 아웃룩 닷컴 API와 같은 여러 웹 서비스를 호출하는 TeamFinder 객체를 만들었다.
- ![1-8](/assets/img/post/AKKA/ch1/1-8.png)
- **문제점**
  - 이 서비스중 하나가 자주 실패하곤 하며, 그마저도 가장 나쁜방식(시간이 많이 지나고 난 뒤 타임아웃이 발생하거나, 트래픽이 초당 몇 바이트 수준으로 느려짐)으로 문제를 일으킨다는 것을 발견했다.
  - 이런 웹 서비스를 하나씩 차례대로 호출해서 응답을 기다리므로 정상적으로 응답하는 서비스들로부터 가져온 응답만으로도 충분히 좋은 제안을 사용자에게 제공할 수 있음에도 불구하고 실패한 서비스 하나 때문에 한참 흐른 다음에 TemaFinder 서비스 전체가 실패한다.
  - 데이터 베이스 메서드를 DAO에 연락처 검색을 TeamFinder 객체에 모아뒀음에도 불구하고 컨트롤러는 이런 메서드를 다른 메서드와 마찬가지로 호출하고 있다. 이는 경우에 따라서 두 데이터베이스 메서드 호출 사이에 사용자 검색이 일어날 수 있다는 것을 의미한다. 이 때문에 데이터 베이스 연결이 필요한 것보다 더 오래 유지되면 결국 데이터 베이스 자원을 모두 잡아먹게 될 지도 모른다.
  - 어떻게 하면 코드의 다른 부분과 TeamFinder를 분리할 수 있을까?

## ✅ 1.5 아카를 사용한 규모 확장
### 1.5.1 아카를 사용한 규모 확장과 내구성 : 메시지 송수신
- 대화에 속한 메시지를 복구할 때만 데이터 베이스를 사용했다.
- Conversation 액터는 메시지를 로그에 보내고, 애플리케이션이 시작할 때 로그에서 메시지를 다시 받는다.

#### 변경사항을 이벤트의 시퀀스로 유지함
- Journal : 모든 이벤트를 리플레이하면 현재상태를 다시 구성할 수 있는 데이터 베이스 (기법 : 이벤트 소싱)
- 저널은 균일한 서비스라는 것이다. 저널이 하는 일은 모든 이텐트를 순서대로 저장하는 것과 저장했던 순서 그대로 이벤트를 다시 불러오는 것 뿐이다.

#### 데이터 전파하기 : 대화의 공유
- Sharding, partitioning : 어디에 어떤 대화가 있는지를 추적할 수 있게 예측 가능한 방법을 사용해 대화를 여러 서버로 분산시키는 것이다.

### 1.5.2 아카를 사용한 규모 확장과 상호 작용 : 푸시 메시지

### 1.5.3 아카를 사용한 규모 확장과 실패 : 비동기 디커플링

### 1.5.4 아카의 접근 방법: 메시지 송신과 수신

## ✅ 1.6 액터 : 한가지 프로그래밍 모델로 수직/수평 확장을 동시에 할 수 있음
### 1.6.1 비동기 모델
- 애플리케이션의 규모를 여러 서버에 걸쳐 키우려 한다면, 프로그래밍 모델에 중요한 요구 사항은 바로 `비동기`적이여야 한다는 것이다.
- 이는 채팅 어플리케이션과 마찬가지로 어떤 컴포넌트가 다른 컴포넌트의 응답을 아직 받지 못했을 때도 계속해서 필요한 일을 수행할 수 있어야 한다는 말이다.
- 예를 들어, 슈퍼바이저가 동기 통신을 사용해서 매번 모든 컴포넌트의 모든 응답을 기다린다면, 컴포넌트 중 어느 하나가 응답하지 않을 때 블로킹으로 인해 다른 모든 호출이 일어날 수 없어 문제가 될 수 있다.

### 1.6.2. 액터 연산
#### 송신(Send)
- 액터가 다른 액터와 의사소통하는 방법은 오직 메시지를 보내는 방법밖에 없다.
- 액터는 내부 상태에 대한 외부 접근을 허용하지 않는다. 예를 들어, 대화 목록을 Conversation 액터 외부에서 볼 수 있는 방법은 없다.
- 액터는 병경 가능한 상태를 남과 공유하지 않는다. 즉, 대화에서 오간 메시지 목록을 공유하거나 어떤 시점에 동시에 그런 대화를 변경하는 일은 없다. 다른 액터에게 메시지를 보내야만 한다. 메시지 송신은 항상 `비동기적`이며, 발사 후 망각 스타일로 이뤄진다. 다른 액터가 메시지를 받았는지 꼭 알아야 한다면 메시지를 받은 액터가 수신 통지 메시지를 다시 보내주면 된다.
- Conversation 액터는 메시지를 Mentions 액터에게 보낸 다음 어떤 일이 벌어지는지를 살펴보지 않아도 된다. 즉, `메시지를 보내고 자기 할 일을 계속할 수 있다.` 이제는 메시지 큐가 필요 없다.
- 메시지는 `변경 불가능`해야 한다. 즉 메시지를 생성한 다음에는 그 내용을 바꿀 수 없어야 한다. 이는 두 액터가 같은 메시지를 동시에 변경하는 것을 피하기 위함이다. 같은 메시지를 두 액터가 동시에 변경한다면 예측할 수 없는 동작이 일어날 수도 있기 때문이다.
- 사용자가 Conversation에 있는 메시지를 변경하고 싶을 때는 어떻게 해야 할까?
  - 공유된 메시지 목록에 있는 메시지를 직접 그 자리에서 수정하는 대신 변경한 메시지 복사본을 EditMessage에 담아서 보낼 수 있다. Conversation 액터는 EditMessage를 받아서 기존의 메시지를 새로운 복사본으로 대체한다.
- 송신 액터와 수신 액터 사이에는 전송된 메시지의 순서가 유지된다. 액터는 메시지를 `한 번에 하나씩만 받는다.`

## ⭐정리⭐